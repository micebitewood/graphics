
import java.awt.Color;
import java.awt.Graphics;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * MainFrame.java
 *
 * Created on 2010-4-24, 15:20:32
 */
/**
 *
 * @author Administrator
 */
public class MainFrame extends javax.swing.JFrame {

	/** Creates new form MainFrame */
	public MainFrame() {
		initComponents();
		g = P.getGraphics();
		this.setSize((N + 3) * size, (N + 6) * size + 20);
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    ToolBar = new javax.swing.JToolBar();
    JL_N = new javax.swing.JLabel();
    TF_N = new javax.swing.JTextField();
    JB_Make = new javax.swing.JButton();
    JB_Find = new javax.swing.JButton();
    P = new java.awt.Panel();

    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

    ToolBar.setRollover(true);

    JL_N.setText("n = ");
    ToolBar.add(JL_N);

    TF_N.setText("50");
    TF_N.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        TF_NActionPerformed(evt);
      }
    });
    ToolBar.add(TF_N);

    JB_Make.setText("Make");
    JB_Make.setFocusable(false);
    JB_Make.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    JB_Make.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    JB_Make.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        JB_MakeActionPerformed(evt);
      }
    });
    ToolBar.add(JB_Make);

    JB_Find.setText("Find");
    JB_Find.setFocusable(false);
    JB_Find.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    JB_Find.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    JB_Find.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        JB_FindActionPerformed(evt);
      }
    });
    ToolBar.add(JB_Find);

    getContentPane().add(ToolBar, java.awt.BorderLayout.NORTH);

    P.setLayout(new java.awt.BorderLayout());
    getContentPane().add(P, java.awt.BorderLayout.CENTER);

    pack();
  }// </editor-fold>//GEN-END:initComponents

		private void JB_MakeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_JB_MakeActionPerformed
			setFrameSize();
			for (int i = 0; i <= n + 1; i++) {
				for (int j = 0; j <= n + 1; j++) {
					if (i == 0 || i == n + 1 || j == 0 || j == n + 1) {
						Maze[i][j] = -1;
					} else {
						Maze[i][j] = 3;
					}
				}
			}
			genmaze(n / 2, n / 2);
			Maze[n][n] &= 0xd;

			g.setColor(Color.black);
			g.clearRect(0, 0, (N + 3) * size, (N + 3) * size);
			//outer
			g.drawLine(size, 2 * size, size, (n + 1) * size);
			g.drawLine(size, (n + 1) * size, (n + 1) * size, (n + 1) * size);


			//inter
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					if ((Maze[i][j] & 1) == 1) {
						g.drawLine(j * size, i * size, (j + 1) * size, i * size);
					}
					if ((Maze[i][j] & 2) == 2) {
						g.drawLine((j + 1) * size, i * size, (j + 1) * size, (i + 1) * size);
					}
				}
			}
		}//GEN-LAST:event_JB_MakeActionPerformed

		private void JB_FindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_JB_FindActionPerformed
			FindPath(1, 1);
		}//GEN-LAST:event_JB_FindActionPerformed

		private void TF_NActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TF_NActionPerformed
			setFrameSize();
		}//GEN-LAST:event_TF_NActionPerformed

	private void setFrameSize() {
		try {
			n = Integer.parseInt(TF_N.getText());
			if (n > 50) {
				n = 50;
				TF_N.setText("" + n);
			} else if (n < 5) {
				n = 5;
				TF_N.setText("" + n);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void genmaze(int i, int j) {
		int dir;
		Maze[i][j] |= 0x4;
		while (Maze[i][j + 1] == 3 || Maze[i + 1][j] == 3 || Maze[i][j - 1] == 3 || Maze[i - 1][j] == 3) {
			dir = (int) (4 * Math.random() + 1);
			if (dir == 1 && Maze[i][j + 1] == 3) {
				Maze[i][j] &= 0xd;
				genmaze(i, j + 1);
			} else if (dir == 2 && Maze[i - 1][j] == 3) {
				Maze[i][j] &= 0xe;
				genmaze(i - 1, j);
			} else if (dir == 3 && Maze[i][j - 1] == 3) {
				Maze[i][j - 1] &= 0xd;
				genmaze(i, j - 1);
			} else if (dir == 4 && Maze[i + 1][j] == 3) {
				Maze[i + 1][j] &= 0xe;
				genmaze(i + 1, j);
			}
		}
	}

	void drawPath() {
		g.setColor(Color.red);
		int i = 1, j = 1;
		while(i != n || j != n) {
			if ((Maze[i][j] & 0x80) == 0x80) {
				g.drawLine(j * size + size / 2, i * size + size / 2, j * size + size / 2, i * size - size / 2);
				i--;
			} 
			else if ((Maze[i][j] & 0x40) == 0x40) {
				g.drawLine(j * size + size / 2, i * size + size / 2, j * size + size / 2, i * size + 3 * size / 2);
				i++;
			} 
			else if ((Maze[i][j] & 0x20) == 0x20) {
				g.drawLine(j * size + size / 2, i * size + size / 2, j * size - size / 2, i * size + size / 2);
				j--;
			} 
			else if ((Maze[i][j] & 0x10) == 0x10) {
				g.drawLine(j * size + size / 2, i * size + size / 2, j * size + 3 * size / 2, i * size + size / 2);
				j++;
			}
		}
		g.drawLine(size, size + size / 2, size + size / 2, size + size / 2);
		g.drawLine(n * size + size / 2, n * size + size / 2, n * size + size, n * size + size / 2);
	}

	void FindPath(int x, int y) {
		if (x == n && y == n) {
			drawPath();
		} else {
			Maze[x][y] |= 0x8;
			//up
			if (Maze[x - 1][y] != -1 && (Maze[x - 1][y] & 8) == 0 && (Maze[x][y] & 1) == 0) {
				Maze[x][y] |= 0x80;
				Maze[x][y] &= 0x8f;
				FindPath(x - 1, y);
			}
			//down
			if (Maze[x + 1][y] != -1 && (Maze[x + 1][y] & 8) == 0 && (Maze[x + 1][y] & 1) == 0) {
				Maze[x][y] |= 0x40;
				Maze[x][y] &= 0x4f;
				FindPath(x + 1, y);
			}
			//left
			if (Maze[x][y - 1] != -1 && (Maze[x][y - 1] & 8) == 0 && (Maze[x][y - 1] & 2) == 0) {
				Maze[x][y] |= 0x20;
				Maze[x][y] &= 0x2f;
				FindPath(x, y - 1);
			}
			//right
			if (Maze[x][y + 1] != -1 && (Maze[x][y + 1] & 8) == 0 && (Maze[x][y] & 2) == 0) {
				Maze[x][y] |= 0x10;
				Maze[x][y] &= 0x1f;
				FindPath(x, y + 1);
			}
		}
	}

	/**
	 * @param args the command line arguments
	 */
	public static void main(String args[]) {
		java.awt.EventQueue.invokeLater(new Runnable() {

			public void run() {
				new MainFrame().setVisible(true);
			}
		});
	}
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton JB_Find;
  private javax.swing.JButton JB_Make;
  private javax.swing.JLabel JL_N;
  private java.awt.Panel P;
  private javax.swing.JTextField TF_N;
  private javax.swing.JToolBar ToolBar;
  // End of variables declaration//GEN-END:variables
	private final int N = 50;
	private int n = N;
	private int size = 10;
	private int Maze[][] = new int[N + 2][N + 2];
	private Graphics g;
}
